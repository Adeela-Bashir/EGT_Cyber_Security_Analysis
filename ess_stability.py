# -*- coding: utf-8 -*-
"""ESS_Stability

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rs49kKFRrwSyF9La2DH8utWHtpq-S__P
"""

pip install nashpy

import nashpy as nash
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import fsolve
from numpy.linalg import eig

# Parameters
c = 1 # cost of attack
d = 1 # cost of defence
m = 0 # probability of catching attacker for unsuccessful attack
n = 0 # probability of catching attacker for successful attack
w = 5 # Loss to the defender
r = 10 # Ratio of attack benefit to the defender's loss
v = 0 # probability of successful defence

a = (1 / r) * w # benefit of attack
b = w # benefit of defence
p = 0
s = 0

# Payoff matrices based on the given parameters
payoff_defender = np.array([
        [ 0, -w],
        [-d+b, -d + v*b - w*(1 - v)],
    ])
payoff_attacker = np.array([
        [ 0, 0],
        [-c+a - m* p, -c+a*(1-v) - v * n * s - (1-v) *m * p],
    ])

prisoners_dilemma = nash.Game(payoff_defender, payoff_attacker)
prisoners_dilemma

# Define the replicator dynamics equations
def F_beta(beta, alpha):
    return beta * (1 - beta) * (b - d - b*alpha + v*b*alpha + v*w*alpha)

def F_alpha(alpha, beta):
    return alpha * (1 - alpha) * (-c + a - m*p - a*v*beta - v*n*s*beta + v*m*p*beta)

# Jacobian matrix to determine stability
def jacobian(beta, alpha):
    # Partial derivative of F_beta with respect to alpha
    dF_beta_dalpha = beta * (1 - beta) * (-b + v*b + v*w)

    # Partial derivative of F_alpha with respect to beta
    dF_alpha_dbeta = alpha * (1 - alpha) * (-a*v - v*n*s + v*m*p)

    # Partial derivative of F_beta with respect to beta
    dF_beta_dbeta = (1 - 2 * beta) * (b - d - b*alpha + v*b*alpha + v*w*alpha)
                    #+ \(1 - 2 * beta) * beta * (1 - beta)

    # Partial derivative of F_alpha with respect to alpha
    dF_alpha_dalpha = (1 - 2 * alpha) * (-c + a - m*p - a*v*beta - v*n*s*beta + v*m*p*beta)
                      #+ \(1 - 2 * alpha) * alpha * (1 - alpha)

    # Return the 2x2 Jacobian matrix
    #return np.array([[dF_alpha_dalpha, dF_alpha_dbeta],
      #               [dF_beta_dalpha, dF_beta_dbeta]])

    return np.array([[dF_beta_dbeta, dF_beta_dalpha],
                     [dF_alpha_dbeta, dF_alpha_dalpha]])

# Example values for alpha and beta
alpha = 0
beta = 1

# Call the jacobian function and print the result
J = jacobian(beta, alpha)
print("Jacobian matrix:")
print(J)

# Function to find equilibrium points by solving the system F_alpha = 0, F_beta = 0
def equilibrium_points(guess):
    def equations(p):
        alpha, beta = p
        return (F_beta(beta, alpha), F_alpha(alpha, beta))
    return fsolve(equations, guess)

# Get equilibrium points with a rough guess
equilibria = equilibrium_points([0, 1])

alpha_eq, beta_eq = equilibria
print(f"Equilibrium point: beta = {beta_eq}, alpha = {alpha_eq}")

# Compute the Jacobian matrix at the equilibrium point
J = jacobian(beta_eq, alpha_eq)
print(f"Jacobian matrix at equilibrium:\n{J}")

# Calculate eigenvalues to determine stability
eigenvalues = eig(J)[0]
print(f"Eigenvalues: {eigenvalues}")

# Stability classification based on eigenvalues
if np.all(np.real(eigenvalues) < 0):
    stability = "Stable"
    color = 'green'
elif np.all(np.real(eigenvalues) > 0):
    stability = "Unstable"
    color = 'red'
else:
    stability = "Saddle"
    color = 'orange'

print(f"Stability: {stability}")

# Plot the phase diagram and equilibrium points
alpha_vals = np.linspace(0, 1, 100)
beta_vals = np.linspace(0, 1, 100)
alpha_grid, beta_grid = np.meshgrid(alpha_vals, beta_vals)

F_alpha_vals = F_alpha(alpha_grid, beta_grid)
F_beta_vals = F_beta(beta_grid, alpha_grid)

plt.figure(figsize=(8, 6))
plt.streamplot(alpha_vals, beta_vals, F_alpha_vals, F_beta_vals, color='blue', density=1.2)

# Plot the equilibrium point
plt.plot(alpha_eq, beta_eq, 'o', color=color, label=f'{stability} Equilibrium')

# Label the equilibrium point on the graph
plt.text(alpha_eq + 0.02, beta_eq + 0.02, f'{stability} ({alpha_eq:.2f}, {beta_eq:.2f})',
         color=color, fontsize=12, weight='bold')

# Labels and legend
plt.xlabel('Attacker (alpha)')
plt.ylabel('Defender (beta)')
plt.title('Replicator Dynamics Phase Diagram')

# Adding a legend to distinguish stable, unstable, and saddle points
plt.legend()

# Show the plot
plt.grid(True)
plt.show()
